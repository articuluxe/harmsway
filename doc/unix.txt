# -*- Mode: sh; comment-start: "#" -*-
# unix.txt --- misc. helpful commands
# Copyright (C) 2015, 2016   (dan.harms)
# Author:  <dan.harms@xrtrading.com>
# Created: Friday, March 20, 2015
# Version: 1.0
# Modified Time-stamp: <2016-08-11 12:58:10 dan.harms>
# Modified by: Dan Harms
# Keywords: help

# find git
wget http://kernel.org/pub/software/scm/git/git-2.1.4.tar.gz

# install x
yum groupinstall basic-desktop desktop-platform x11 fonts
# change default runlevel in /etc/inittab:
id:5:initdefault:

# find all libraries defining a symbol
find /path/to/root -name \*.a -exec sh -c 'nm -C "$0" | grep symbol && echo "$0"' {} \;
# find with multiple -exec (short-circuit)
find . -name "pattern" -exec echo {} \; -exec grep <str> {} \;
# find with multiple -exec (non-short-circuit)
find . -name "pattern" \( -exec echo {} \; -o -exec true \; \) -exec grep <str> {} \;

# find a compiler's set of include directories (works on gcc and clang)
g++/clang++ -E -x c++ - -v < /dev/null

# ensure core dump on SEGV
ulimit -c unlimited
# limit interface mtu (current session)
ifconfig eth0 mtu 1000
# limit interface mtu (persistent)
# edit /etc/sysconfig/network-scripts/ifcfg-eth0
MTU=1000
# show process using a file
fuser
# print out a process's call stack
pstack <pid>
# find out which distro you're running
facter lsbdistrelease
cat /etc/*-release

# convert from .erf to .pcap
tshark -r <file>.erf -q -z io,phs
editcap -F libpcap -T ether <file>.erf <file>.pcap

# repeat a command every n seconds
watch -n 5 who
# repeat a command in a loop
while sleep 1; do who; done

# compile emacs
mkdir bld && cd bld
../configure [--with-png=no]

# compare 2 directories
diff -qr one two
comm -3 <(ls -l one) <(ls -l two)

################################# wireshark ##################################
# list interfaces
tshark -D
# capture
tshark -i<interface> -w <output>.pcap
# capture files up to 10240 KB or after 1 second elapsed
tshark -b filesize:10240 -b duration:1 -w <output>.pcap
# capture 20 files each 100 KB, then stop
tshark -b filesize:100 -a files:20 -w <output>.pcap
# rolling capture of 4 GB of data (128 files of 32 MB)
dumpcap -i<interface> -w <output>.pcap -b filesize:32768 -b files:128
# filters:
fix and ip.[addr|src|dst] == 69.50.112.200
# match first 3 octets
ip.src == 69.50.112.200/24

# close a socket without killing process
netstat -np
# locate socket's file descriptor within process
lsof -np <pid>
# connect to process
gdb -p <pid>
"call close(<fd>)" "q"

################################ command line ################################
# last command
!!
# run last command <cmd>
!<cmd>
# last command beginning with <prefix>
!<prefix>
# last command containing <substring>
!?<substring>?
# entire command line typed so far
!#
# last command's [last] argument
!$
# last command's 1st argument
!^
# all of last command's arguments
!*
# <cmd>'s nth argument
!<cmd>:n
# last ls command's third through fifth arguments
!ls:3-5
# edit prior command (1st occurrence)
^replace^replacement
# edit prior command (all occurrences) (use & in new to refer to old
!!:gs/old/new
# multiple files
touch file{1,2,3}
# rename
mv file.{old,new}
# operate on all files except python/shell
rm !(*.py|*.sh)
# result of last command
$?
# edit current line using $EDITOR, then execute
\C-x \C-e
# execute current line, then present subsequent from history
\C-o

# redirect stderr
<command> 2> output.txt
# redirect stderr to stdout
<command> 1>&2
<command> 2>&1
# redirect stdout+stderr
<command> &> output.txt
# redirect all output to a single file on DOS:
<command> [args] > output.txt 2>&1

#################################### awk #####################################
# seach a field for a specific regex
awk '$5 ~ /regex/ {print $5;}' file
# look at TAB-separated values
awk 'BEGIN {FS="\t"}; {if ($12 == "ESH6") print $40; }' <file>
# average a column
awk '/^num/ {n++; sum+=$2} END {print n?sum/n:0}' file
# echo lines with fewer lines
awk -F, 'NF < 18 { print $0;}' <file>
# find which column matches a regex
head -1 file.csv | awk -F, '{for (i=1; i <= NF; ++i) { if ($i ~ /regex/) {print i,$i;}}}'

#################################### cron ####################################
# ensure service is running
service crond/atd status
# edit/list/remove cron for current user
crontab -e [l r]
# add an at job (Ctrl-D ends)
at HH:MM/midnight/noon/teatime
at MMDDYY
at now + 1 minutes/hours/days/weeks
# view pending jobs for current user
atq

# code ends here
