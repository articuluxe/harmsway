# -*- Mode: sh; comment-start: "#" -*-
# unix.txt --- misc. helpful commands
# Copyright (C) 2015   (dan.harms)
# Author:  <dan.harms@xrtrading.com>
# Created: Friday, March 20, 2015
# Version: 1.0
# Modified Time-stamp: <2015-08-17 14:58:33 dan.harms>
# Keywords: help

# install x
yum groupinstall basic-desktop desktop-platform x11 fonts
# change default runlevel in /etc/inittab:
id:5:initdefault:

# find all libraries defining a symbol
find /path/to/root -name \*.a -exec sh -c 'nm -C "$0" | grep symbol && echo "$0"' {} \;

# ensure core dump on SEGV
ulimit -c unlimited
# limit interface mtu (current session)
ifconfig eth0 mtu 1000
# limit interface mtu (persistent)
# edit /etc/sysconfig/network-scripts/ifcfg-eth0
MTU=1000
# show process using a file
fuser
# print out a process's call stack
pstack <pid>
# find out which distro you're running
cat /etc/*-release

# convert from .erf to .pcap
tshark -r <file>.erf -q -z io,phs
editcap -F libpcap -T ether <file>.erf <file>.pcap

#################################### gdb #####################################
# print first 8 elements of a std::vector<std::string> vec
p *(vec._M_impl._M_start)@8
# print first 20 characters of a std::string
p *(str._M_dataplus._M_p)@20
# print raw memory as 21 hex bytes
x/21xb 0x0000abcd
# print as null-terminated string
x/1sb 0x00abcd01
# show last instruction
x/i $pc
disas $pc
# conditional breakpoints
break <line> if strcmp(str, "str") == 0

################################ command line ################################
# last command
!!
# run last command <cmd>
!<cmd>
# last command beginning with <prefix>
!<prefix>
# last command containing <substring>
!?<substring>?
# last command's [last] argument
!$
# last command's 1st argument
!^
# all of last command's arguments
!*
# <cmd>'s nth argument
!<cmd>:n
# edit prior command (1st occurrence)
^replace^replacement
# edit prior command (all occurrences)
!!:gs/replace/replacement
# multiple files
touch file{1,2,3}
# rename
mv file.{old,new}
# operate on all files except python/shell
rm !(*.py|*.sh)
# result of last command
$?
# edit current line using $EDITOR, then execute
\C-x \C-e
# execute current line, then present subsequent from history
\C-o

# redirect stderr
<command> 2> output.txt
# redirect stderr to stdout
<command> 1>&2
<command> 2>&1
# redirect stdout+stderr
<command> &> output.txt

# unix.txt ends here
